# ðŸŸ¢ Day 12 â€“ Backtracking

## ðŸŽ¯ Objective
- Understand backtracking
- Learn difference between recursion and backtracking
- Learn backtracking template
- Generate subsets
- Generate permutations
- Understand exponential time complexity

---

# ðŸ”¹ What is Backtracking?

Backtracking is an algorithmic technique that:

- Makes a choice
- Explores the result of that choice
- Undoes the choice
- Tries another possibility

It is used to explore all possible solutions.

---

# ðŸ”¹ Recursion vs Backtracking

| Recursion | Backtracking |
|------------|--------------|
| Solves smaller subproblems | Explores decision tree |
| Linear flow | Tree-like exploration |
| No undo step | Has undo step |

Backtracking = Recursion + Undo step

---

# ðŸ”¹ Backtracking Template

```python
def backtrack(path, choices):
    if base_condition:
        print(path)
        return

    for choice in choices:
        make_choice
        backtrack(updated_path, remaining_choices)
        undo_choice
```

The undo step is very important.

---

# ðŸ”¹ Example 1 â€“ Generate All Subsets

For:
nums = [1,2]

Subsets:
[]
[1]
[2]
[1,2]

---

## Code

```python
def subsets(nums, path=[], index=0):
    if index == len(nums):
        print(path)
        return

    # Include current element
    subsets(nums, path + [nums[index]], index + 1)

    # Exclude current element
    subsets(nums, path, index + 1)

subsets([1,2])
```

---

# ðŸ”¹ Number of Subsets

If array has n elements:

Total subsets = 2^n

Time Complexity: O(2^n)

---

# ðŸ”¹ Example 2 â€“ Generate All Permutations

For:
nums = [1,2,3]

Permutations:
[1,2,3]
[1,3,2]
[2,1,3]
[2,3,1]
[3,1,2]
[3,2,1]

---

## Code

```python
def permute(nums, path=[]):
    if not nums:
        print(path)
        return

    for i in range(len(nums)):
        permute(nums[:i] + nums[i+1:], path + [nums[i]])

permute([1,2,3])
```

---

# ðŸ”¹ Number of Permutations

If array has n elements:

Total permutations = n!

Time Complexity: O(n!)

---

# ðŸ”¹ When to Use Backtracking

Use backtracking when problem asks:

- Generate all subsets
- Generate all permutations
- N-Queens problem
- Sudoku solver
- Maze solving
- Word search
- Combination problems

---

# ðŸ”¹ Complexity Insight

Backtracking problems usually have:

- Exponential time complexity
- Large recursion trees
- Many possible paths

Subsets â†’ O(2^n)  
Permutations â†’ O(n!)

---

# ðŸ”¥ Key Takeaways

- Backtracking explores decision trees
- Always define base case
- Make a choice â†’ Explore â†’ Undo
- Recognize exponential growth
- Used in many interview problems

---






# ðŸš€ End of Day 12
