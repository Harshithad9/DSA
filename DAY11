# ðŸŸ¢ Day 11 â€“ Recursion

## ðŸŽ¯ Objective
- Understand recursion
- Learn base case and recursive case
- Visualize recursion stack
- Understand recursion flow (downward & upward)
- Analyze time and space complexity

---

# ðŸ”¹ What is Recursion?

Recursion is when a function calls itself.

It solves a problem by breaking it into smaller subproblems.

Every recursive function must have:

1. Base Case â†’ stops recursion
2. Recursive Case â†’ calls itself

Without a base case â†’ infinite recursion.

---

# ðŸ”¹ Basic Example

```python
def print_numbers(n):
    if n == 0:
        return
    print(n)
    print_numbers(n-1)

print_numbers(3)
```

Output:
3
2
1
```

This is printing while going DOWN the recursion stack.

---

# ðŸ”¹ Recursion Stack Concept

Each recursive call is stored in memory (stack).

Example:

print_numbers(3)
â†’ print_numbers(2)
â†’ print_numbers(1)
â†’ print_numbers(0)

After reaching base case, execution returns back step by step.

---

# ðŸ”¹ Printing While Coming Back (Post-order)

```python
def print_numbers(n):
    if n == 0:
        return
    print_numbers(n-1)
    print(n)

print_numbers(3)
```

Output:


1
2
3
```

Here printing happens while coming UP the stack.

---

# ðŸ”¹ Printing Before and After Recursion

```python
def print_pattern(n):
    if n == 0:
        return
    print(n)
    print_pattern(n-1)
    print(n)

print_pattern(2)
```

Output:
2
1
1
2
```

This creates a mirror pattern.

---

# ðŸ”¹ Recursion with Return Value (Sum of Numbers)

```python
def sum_numbers(n):
    if n == 0:
        return 0
    return n + sum_numbers(n-1)

print(sum_numbers(3))
```

Output:
6
```

This computes:
3 + 2 + 1 + 0

---

# ðŸ”¹ Factorial Using Recursion

```python
def factorial(n):
    if n == 1:
        return 1
    return n * factorial(n-1)

print(factorial(5))
```

Time Complexity: O(n)  
Space Complexity: O(n)

---

# ðŸ”¹ Important Recursion Rules

- Always define a base case
- Ensure recursive call moves toward base case
- Understand stack flow
- Code before recursion runs while going DOWN
- Code after recursion runs while coming UP

---

# ðŸ”¹ Time Complexity in Recursion

Example:

```python
def fun(n):
    if n == 0:
        return
    fun(n-1)
```

Time Complexity: O(n)  
Space Complexity: O(n)

Because there are n recursive calls stored in stack.

---

# ðŸ”¹ Recognizing Recursion Patterns

- Factorial
- Sum of numbers
- Print numbers
- Reverse string
- Tree traversal
- Backtracking

---

# ðŸ”¥ Key Takeaways

- Recursion breaks problems into smaller versions
- Stack memory stores function calls
- Base case prevents infinite recursion
- Understand flow before writing code
- Analyze time and space complexity carefully

---

# ðŸš€ End of Day 11
